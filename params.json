{
  "name": "Consass",
  "tagline": "Concise SASS. A DRY, maintainable and scalable SCSS solution for styling large scale projects",
  "body": "#consass (Concise SASS)\r\n##A DRY, maintainable and scalable SCSS solution for styling large scale projects\r\n\r\n---\r\n##The main problems with css at large scale apps:\r\n   * CSS is all at the global namespace (just as js is)\r\n   * Refactoring is complex; hard to eliminate dead code (dead selectors)\r\n   * Hard to know the visual output just by looking at the code - usually need to open browser and inspect.\r\n   * Hard to write scoped styling rules without affecting children, as it should be in a components-based application.\r\n   * Bloated stylesheets may lead to performance problems.\r\n   * BEM, Atomic, css modules - its not it.\r\n\r\n---\r\n##Ask yourself: are you happy with your project's css the way it is now?\r\n\r\n---\r\nThe solution consists of 4 parts:\r\n  * [Six guidelines for coding style](#guidelines)\r\n  * [SCSS root-selectors lib](#expressing-a-component-conditional-statesmodes-with-regard-to-the-root-state-class---using-the-root-selectors-library)\r\n  * [Grunt task](#grunt-task)\r\n  * [scss-lint yml config file](#scss-lint-configuration)\r\n\r\n---\r\n##Guidelines\r\nBy following these guidelines, gain control over the css technical debt in your project. \r\n  * Scale as you grow\r\n  * Refactor easily\r\n  * Easy to step into someone else's code\r\n  * Easy to integrate into an existing project\r\n\r\n---\r\n##The *most important* guideline\r\n   * Split css to scss modules following the projects components abstraction (e.g. rt files)\r\n   * For each file `filename.rt`, create a `filename.scss` file next to it in the same folder .\r\n   * Only write style rules which refer to the DOM structure that belongs to the specific RT. \r\n\r\n---\r\n##Best practices\r\n\r\n---\r\n#####1. One scss file per rt file (also per svg file, skin, or any other piece of dom/template file). \r\ne.g:\r\n```bash\r\nangle.rt\r\nangle.scss\r\n```\r\n\r\n---\r\n#####2. Every scss file should have a *single* root selector matching the rt root element. \r\n\r\nEverything else should be nested. This selector should be unique at the application level. e.g:\r\n\r\n```scss\r\n.control-angle {\r\n   position: relative;\r\n   height: 10px;\r\n\r\n   > .control-label {\r\n       font-size: 14px;\r\n   } \r\n}\r\n```\r\n\r\n---\r\n#####3. Styling nested components is done in the nested components corresponding scss file. \r\n\r\ne.g: `angle.rt` has a child component `stepper.rt`, and configuring its style is done in `stepper.scss` using a parent selector:\r\n    \r\n```scss\r\n//stepper.scss:\r\n\r\n.input-stepper {\r\n    position: relative;\r\n\r\n    //overrides:\r\n    .control-angle & {\r\n       position: absolute;\r\n    } \r\n}\r\n```\r\n\r\n---\r\n#####4. Always prefer immediate child selector (>) over regular descendent selector: \r\nthey perform better, and they also help preventing bleeding css to nested components.\r\n    \r\n```scss\r\n//dont:\r\n.parent-class {\r\n    //dont:\r\n    .child-class {\r\n        color: red;\r\n    }\r\n\r\n    //do:\r\n    > .child-class {\r\n        color: red;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n#####5. Avoid tagName selectors, prefer a semantic class selector:\r\n\r\n```scss\r\n.component {\r\n    //dont:\r\n    span {\r\n        font-size: 14px;\r\n    }\r\n    \r\n    //do:\r\n    > .button-label {\r\n            font-size: 14px;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n#####6. Avoid wildcard selectors (*) - they affect child components and bleed css.\r\n```scss\r\n//dont:\r\n* {\r\n\r\n}\r\n\r\n//do: specify what you style\r\n.selector1,\r\n.selector2, \r\n.selector3 {\r\n        //css here\r\n}\r\n```\r\n\r\n---\r\n##Expressing a component conditional states/modes with regard to the root state (class) - using the root-selectors library \r\n\r\n---\r\n* Given a simple component with some nesting:\r\n\r\n```scss\r\n.a-root-selector {\r\n  > .a-first-child {\r\n    > .a-second-child {\r\n      color: blue;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n---\r\nIf we want `.a-second-child` to receive `color: orange;` when the component has another root class. (e.g. `.show-on-all-pages`), we can use the ancestor selector (`&`):\r\n\r\n```scss\r\n.a-root-selector {\r\n  > .a-first-child {\r\n    > .a-second-child {\r\n      color: blue;\r\n      .show-on-all-pages & {\r\n        color: orange\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n---\r\nIt will give us the following css, where `.show-on-all-pages` is an ancestor or `.a-root-selector`:\r\n\r\n```css\r\n.a-root-selector > .a-first-child > .a-second-child {\r\n  color: blue;\r\n}\r\n\r\n.show-on-all-pages .a-root-selector > .a-first-child > .a-second-child {\r\n  color: orange;\r\n}\r\n```\r\n\r\n---\r\nIf you need to have it on the same root selector, you'll need to use a mixin:\r\n```scss\r\n.a-root-selector {\r\n  > .a-first-child {\r\n    > .a-second-child {\r\n      color: blue;\r\n      @include when-root-has-class(show-on-all-pages) {\r\n        color: orange;\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n---\r\nWill give you the following css (note there is no space)\r\n```css\r\n.a-root-selector > .a-first-child > .a-second-child {\r\n  color: blue;\r\n}\r\n\r\n.show-on-all-pages.a-root-selector > .a-first-child > .a-second-child {\r\n  color: orange;\r\n}\r\n```\r\n\r\n---\r\nSimilarly, the following SCSS mixins are available for your use as part of the framework:<br><br>\r\nClasses modes for a selector:<br>\r\n* `when-root-has-class($class-name)`: when the specified classes is authored on the root level.\r\n* `when-root-has-any-class($class-names)`: one of the specified classes (one or many) is authored on the root level\r\n* `when-root-has-all-classes($class-names)`: all specified classes (one or many) are authored on the root level\r\n\r\n---\r\nPseudo class modes for a selector:<br>\r\n* `when-root-has-pseudo-class($pseudo-class)`: The specified pseudo class is authored on the root level\r\n* `when-root-has-all-pseudo-classes($pseudo-classes)`: all specified pseudo classes are authored on the root level\r\n* `when-root-has-any-pseudo-classes($pseudo-class-names)`: any of the specified pseudo classes are authored on the root level.\r\n\r\n---\r\nclass and pseudo-class together<br>\r\n* `when-root-has-all($class-names, $pseudo-class-names)`: all specified combination of class names and pseudo classes are authored on the root level.\r\n* `when-root-has-any($class-names, $pseudo-class-names)`: any of the specified combination of class names/pseudo class names are authored on the root level.\r\n\r\n---\r\nAncestor conditions:<br>\r\n* `when-parent-has-pseudo($pseudo-classes)`: if previous part of selector has the specified pseudo classes, apply the styling.\r\n* `when-ancestor-has-pseudo($pseudo-classes, $levels)`: when an ancestor up the selector has the specified pseudo classes, apply the styling. The ancestor is specified by an number of levels up the selector.\r\n* see [root selector helpers](https://github.com/wix/santa-editor/blob/master/packages/baseUI/src/main/framework/rootSelectorHelpers.scss)\r\n\r\n---\r\n##Example: A custom checkbox \r\n  * Specified colors for various different modes (regular / hover / selected)\r\n  * Needs to have a \"beautiful\" mode which specifies different styling.\r\n(See the Pen <a href='http://codepen.io/eitaneitan/pen/zqeMZM/'>zqeMZM</a> by Eitan (<a href='http://codepen.io/eitaneitan'>@eitaneitan</a>) on <a href='http://codepen.io'>CodePen</a>.)\r\n\r\n```html\r\n<label class=\"control-checkbox\">\r\n  <input type=\"checkbox\" class=\"input\" />\r\n  <div class=\"content\"></div>\r\n</label>\r\n```\r\n\r\n---\r\n```scss\r\n.control-checkbox {\r\n  display: inline-block;\r\n  cursor: pointer;\r\n\r\n  > .input {\r\n    display: none;\r\n\r\n    + .content {\r\n      width: 28px;\r\n      height: 28px;\r\n      background-color: red;\r\n      border: solid 3px blue;\r\n    }\r\n\r\n    &:checked + .content {\r\n      background-color: green;\r\n    }\r\n  }\r\n\r\n  &:hover > .input + .content {\r\n    background-color: yellow;\r\n  }\r\n\r\n  &.beautiful {\r\n    > .input {\r\n      + .content {\r\n        background-color: cyan;\r\n        border-color: lime;\r\n        border-radius: 50%;\r\n      }\r\n      \r\n      &:checked + .content {\r\n        background-color: orange;\r\n      }\r\n    }\r\n    \r\n    &:hover {\r\n      > .input + .content {\r\n        background-color: grey;\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n---\r\nA better approach: DRY, concise, extensible, refactorable, DOM-like structure:\r\n```scss\r\n.control-checkbox {\r\n  display: inline-block;\r\n  cursor: pointer;\r\n\r\n  > .input {\r\n    display: none;\r\n\r\n    + .content {\r\n      width: 28px;\r\n      height: 28px;\r\n      background-color: red;\r\n      border: solid 3px blue;\r\n      \r\n      @include when-parent-has-pseudo(checked) {\r\n        background-color: green;        \r\n      }\r\n      \r\n      @include when-root-has-pseudo-class(hover) {\r\n        background-color: yellow;        \r\n      }\r\n      \r\n      @include when-root-has-class(beautiful) {\r\n        background-color: cyan;\r\n        border-radius: 50%;\r\n        border-color: lime;\r\n        \r\n        @include when-parent-has-pseudo(checked) {\r\n          background-color: orange;\r\n        }\r\n        \r\n        @include when-root-has-pseudo-class(hover) {\r\n          background-color: grey;          \r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n---\r\nCompiled CSS Code:\r\n```css\r\n.control-checkbox {\r\n  display: inline-block;\r\n  cursor: pointer;\r\n}\r\n.control-checkbox > .input {\r\n  display: none;\r\n}\r\n.control-checkbox > .input + .content {\r\n  width: 28px;\r\n  height: 28px;\r\n  background-color: red;\r\n  border: solid 3px blue;\r\n}\r\n.control-checkbox > .input:checked + .content {\r\n  background-color: green;\r\n}\r\n.control-checkbox:hover > .input + .content {\r\n  background-color: yellow;\r\n}\r\n.beautiful.control-checkbox > .input + .content {\r\n  background-color: cyan;\r\n  border-radius: 50%;\r\n  border-color: lime;\r\n}\r\n.beautiful.control-checkbox > .input:checked + .content {\r\n  background-color: orange;\r\n}\r\n.beautiful.control-checkbox:hover > .input + .content {\r\n  background-color: grey;\r\n}\r\n```\r\n---\r\n##Grunt task \r\nensure namespaces uniqueness in the project's SCSS files at build time\r\n<br>TBD\r\n\r\n---\r\n##scss-lint configuration\r\nThese REALLY assist with getting things in order:\r\n```ruby\r\n  DeclarationOrder:\r\n    enabled: true\r\n\r\n  DisableLinterReason:\r\n    enabled: true\r\n\r\n  DuplicateProperty:\r\n    enabled: true\r\n\r\n  SingleLinePerProperty:\r\n    enabled: true\r\n    allow_single_line_rule_sets: false\r\n\r\n  SingleLinePerSelector:\r\n    enabled: true\r\n\r\n  MergeableSelector:\r\n    enabled: true\r\n    force_nesting: true\r\n\r\n  EmptyRule:\r\n    enabled: true\r\n```\r\n---\r\n##What did we achieve?\r\n   * All css which affects a certain piece of DOM is always placed next to it in a dedicated scss file. Easy to find and change.\r\n   * scss files become less complex, straight-forward and more performant.\r\n   * Unifying similar style rules becomes easy; Its all in the same scss file.\r\n   * All component style rules are nested in its selector. Nothing at the global scope.\r\n   * When refactoring a react component (changing/deleting), its easy to see where all its css is at.\r\n   * Easy to reuse an existing selector\r\n   * Easy to code without opening a browser\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}